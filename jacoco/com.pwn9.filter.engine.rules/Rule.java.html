<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PwnFilter</a> &gt; <a href="index.source.html" class="el_package">com.pwn9.filter.engine.rules</a> &gt; <span class="el_source">Rule.java</span></div><h1>Rule.java</h1><pre class="source lang-java linenums">/*
 *  PwnFilter - Chat and user-input filter with the power of Regex
 *  Copyright (C) 2016 Pwn9.com / Sage905 &lt;sage905@takeflight.ca&gt;
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 *
 */

package com.pwn9.filter.engine.rules;

import com.pwn9.filter.engine.FilterService;
import com.pwn9.filter.engine.api.Action;
import com.pwn9.filter.engine.api.FilterContext;
import com.pwn9.filter.engine.rules.chain.ChainEntry;
import com.pwn9.filter.util.LimitedRegexCharSequence;

import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Rule object
 * &lt;p&gt;
 * Each Rule has a single match Pattern, an ArrayList of {@link com.pwn9.filter.engine.rules.Condition}'s and an ArrayList of {@link Action}'s
 *
 * @author Sage905
 * @version $Id: $Id
 */
public class Rule implements ChainEntry {
<span class="fc" id="L43">    public static int matches = 0;</span>
<span class="pc" id="L44">    private final List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;();</span>
<span class="pc" id="L45">    private final List&lt;Action&gt; actions = new ArrayList&lt;&gt;();</span>
    private Pattern pattern;
<span class="pc" id="L47">    private String description = &quot;&quot;;</span>
<span class="pc" id="L48">    private String id = &quot;&quot;;</span>

        /* Constructors */

    /**
     * &lt;p&gt;Constructor for Rule.&lt;/p&gt;
     */
<span class="nc" id="L55">    public Rule() {</span>
<span class="nc" id="L56">    }</span>

    /**
     * &lt;p&gt;Constructor for Rule.&lt;/p&gt;
     *
     * @param matchStr a {@link java.lang.String} object.
     */
<span class="fc" id="L63">    public Rule(String matchStr) {</span>
<span class="fc" id="L64">        this.pattern = Pattern.compile(matchStr, Pattern.CASE_INSENSITIVE);</span>
<span class="fc" id="L65">    }</span>

    /**
     * &lt;p&gt;Constructor for Rule.&lt;/p&gt;
     *
     * @param id          a {@link java.lang.String} object.
     * @param description a {@link java.lang.String} object.
     */
<span class="nc" id="L73">    public Rule(String id, String description) {</span>
<span class="nc" id="L74">        this.id = id;</span>
<span class="nc" id="L75">        this.description = description;</span>
<span class="nc" id="L76">    }</span>

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;pattern&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a {@link java.util.regex.Pattern} object.
     */
    public Pattern getPattern() {
<span class="nc" id="L84">        return pattern;</span>
    }

    /**
     * &lt;p&gt;Setter for the field &lt;code&gt;pattern&lt;/code&gt;.&lt;/p&gt;
     *
     * @param pattern a {@link java.lang.String} object.
     */
    public void setPattern(String pattern) {
<span class="nc" id="L93">        this.pattern = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);</span>
<span class="nc" id="L94">    }</span>

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;description&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a {@link java.lang.String} object.
     */
    public String getDescription() {
<span class="nc" id="L102">        return description;</span>
    }

    /**
     * &lt;p&gt;Setter for the field &lt;code&gt;description&lt;/code&gt;.&lt;/p&gt;
     *
     * @param description a {@link java.lang.String} object.
     */
    public void setDescription(String description) {
<span class="fc" id="L111">        this.description = description;</span>
<span class="fc" id="L112">    }</span>

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a {@link java.lang.String} object.
     */
    public String getId() {
<span class="fc" id="L120">        return id;</span>
    }

    /**
     * &lt;p&gt;Setter for the field &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
     *
     * @param id a {@link java.lang.String} object.
     */
    public void setId(String id) {
<span class="fc" id="L129">        this.id = id;</span>
<span class="fc" id="L130">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;String&gt; getConditionsMatching(String matchString) {
<span class="nc" id="L137">        Set&lt;String&gt; retVal = new HashSet&lt;&gt;();</span>
        Condition.CondType matchType;

        try {
<span class="nc" id="L141">            matchType = Condition.CondType.valueOf(matchString);</span>
<span class="nc" id="L142">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L143">            return retVal;</span>
<span class="nc" id="L144">        }</span>

<span class="nc bnc" id="L146" title="All 2 branches missed.">        conditions.stream().filter(c -&gt; c.type == matchType).</span>
<span class="nc" id="L147">                forEach(c -&gt; Collections.addAll(retVal, c.parameters.split(&quot;\\|&quot;)));</span>

<span class="nc" id="L149">        return retVal;</span>
    }

    /* Methods */

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * apply this action to the current message / event.  May trigger other bukkit events.
     */
    public void apply(FilterContext filterContext, FilterService filterService) {

<span class="fc" id="L161">        Logger logger = filterService.getLogger();</span>

        // If finest logging is set, then generate our logging info. (This is a
        // lambda + Supplier pattern.)
<span class="pc" id="L165">        logger.finest(() -&gt; &quot;Testing Pattern: '&quot; + pattern.toString() + &quot;' on string: '&quot; +</span>
<span class="nc" id="L166">                filterContext.getModifiedMessage().toString() + &quot;'&quot;);</span>

        // Check if action matches the current state of the message
<span class="fc" id="L169">        LimitedRegexCharSequence limitedRegexCharSequence =</span>
<span class="fc" id="L170">                new LimitedRegexCharSequence(filterContext.getModifiedMessage().toString(), 1000);</span>
<span class="fc" id="L171">        final Matcher matcher = pattern.matcher(limitedRegexCharSequence);</span>

        // If we don't match, return immediately with the original message
        try {
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (!matcher.find()) return;</span>
<span class="nc" id="L176">        } catch (LimitedRegexCharSequence.RegexTimeoutException ex) {</span>
<span class="nc" id="L177">            logger.severe(&quot;Regex match timed out! Regex: &quot; + pattern.toString());</span>
<span class="nc" id="L178">            logger.severe(&quot;Failed string was: &quot; + limitedRegexCharSequence);</span>
<span class="nc" id="L179">            return;</span>
<span class="nc" id="L180">        } catch (RuntimeException ex) {</span>
            // Note: Due to this:
            // https://stackoverflow.com/questions/16008974/strange-java-unicode-regular-expression-stringindexoutofboundsexception
            // Supplementary UTF characters will cause index-out-of-bounds.  Not sure what to do about this, right now.
<span class="fc" id="L184">        }</span>

        // If we do match, update the pattern and rule in the filter.
<span class="fc" id="L187">        filterContext.setPattern(pattern);</span>
<span class="fc" id="L188">        filterContext.setRule(this);</span>

        // If Match, log it and then check any conditions.
<span class="fc" id="L191">        filterContext.addLogMessage(&quot;|&quot; + filterContext.getFilterClient().getShortName() + &quot;| MATCH &quot; +</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                (id.isEmpty() ? &quot;&quot; : &quot;(&quot; + id + &quot;)&quot;) +</span>
                &quot; &lt;&quot; +
<span class="fc" id="L194">                filterContext.getAuthor().getName() + &quot;&gt; &quot; + filterContext.getModifiedMessage().toString());</span>

<span class="pc" id="L196">        logger.fine(() -&gt; &quot;Match String: &quot; + matcher.group());</span>

<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (Condition c : conditions) {</span>
            // This checks that EVERY condition is met (conditions are AND)
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (!c.check(filterContext)) {</span>
<span class="fc" id="L201">                filterContext.addLogMessage(&quot;CONDITION not met &lt;&quot; + c.flag.toString() +</span>
<span class="fc" id="L202">                        &quot; &quot; + c.type.toString() + &quot; &quot; + c.parameters + &quot;&gt; &quot; + filterContext.getOriginalMessage());</span>
<span class="fc" id="L203">                return;</span>
            }

<span class="fc" id="L206">        }</span>

        // If we get this far, execute the actions
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (Action a : actions) {</span>
<span class="fc" id="L210">            a.execute(filterContext, filterService);</span>
<span class="fc" id="L211">        }</span>

<span class="fc" id="L213">    }</span>

    /**
     * &lt;p&gt;isValid.&lt;/p&gt;
     *
     * @return a boolean.
     */
    public boolean isValid() {
        // Check that we have a valid pattern and at least one action
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">        return this.pattern != null &amp;&amp; this.actions != null;</span>
    }

    /**
     * &lt;p&gt;toString.&lt;/p&gt;
     *
     * @return a {@link java.lang.String} object.
     */
    public String toString() {
<span class="fc" id="L231">        return pattern.toString();</span>
    }

    /**
     * &lt;p&gt;addCondition.&lt;/p&gt;
     *
     * @param c a {@link com.pwn9.filter.engine.rules.Condition} object.
     * @return a boolean.
     */
    public boolean addCondition(Condition c) {
<span class="pc bpc" id="L241" title="2 of 4 branches missed.">        return c != null &amp;&amp; conditions.add(c);</span>
    }

    /**
     * &lt;p&gt;addConditions.&lt;/p&gt;
     *
     * @param conditionList a {@link java.util.Collection} object.
     * @return a boolean.
     */
    public boolean addConditions(Collection&lt;Condition&gt; conditionList) {
<span class="pc bpc" id="L251" title="2 of 4 branches missed.">        return conditionList != null &amp;&amp; conditions.addAll(conditionList);</span>
    }

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;conditions&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a {@link java.util.List} object.
     */
    public List&lt;Condition&gt; getConditions() {
<span class="fc" id="L260">        return conditions;</span>
    }

    /**
     * &lt;p&gt;add.&lt;/p&gt;
     *
     * @param a a {@link Action} object.
     * @return a boolean.
     */
    public boolean addAction(Action a) {
<span class="pc bpc" id="L270" title="2 of 4 branches missed.">        return a != null &amp;&amp; actions.add(a);</span>
    }

    /**
     * &lt;p&gt;addActions.&lt;/p&gt;
     *
     * @param actionList a {@link java.util.Collection} object.
     * @return a boolean.
     */
    public boolean addActions(Collection&lt;Action&gt; actionList) {
<span class="pc bpc" id="L280" title="2 of 4 branches missed.">        return actionList != null &amp;&amp; actions.addAll(actionList);</span>
    }

    /**
     * &lt;p&gt;Getter for the field &lt;code&gt;actions&lt;/code&gt;.&lt;/p&gt;
     *
     * @return a {@link java.util.List} object.
     */
    public List&lt;Action&gt; getActions() {
<span class="fc" id="L289">        return actions;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>